# Basic QPSK Demodulator Implementation

## Objective

Develop a C++ program that simulates a basic Quadrature Phase Shift Keying (QPSK) demodulator. The program will take QPSK symbols as input and map them back to the original binary data stream.

## Detailed Steps

1. Review QPSK Demodulation
- Begin with a study of how QPSK demodulation works. Understand that the process involves converting symbols from the QPSK constellation diagram back into binary pairs. Each symbol's position (its I and Q components) corresponds to a specific pair of bits.
2. Input QPSK Symbols
- Design your program to accept an array or list of QPSK symbols as input. Each symbol will have been generated by your QPSK modulator, meaning it will have specific I (in-phase) and Q (quadrature) components. You may choose to input these symbols through file input, command line arguments, or standard input (stdin).
3. Symbol to Binary Mapping
- Implement a function that maps each QPSK symbol back to its original pair of binary bits. The mapping is based on the quadrant in which the symbol is located on the constellation diagram. For example, a symbol in the first quadrant corresponds to "00", the second quadrant to "01", and so forth.
4. Handling Ideal Conditions
- Since you're assuming ideal conditions without noise, you can map the symbols directly to their nearest constellation point without having to make decisions based on signal quality or interference. This simplifies the demodulation process considerably.
5. Output Binary Sequence
- Determine how you will output the resulting binary sequence. This could be printing it to the console, writing it to a file, or any other method that suits your testing and demonstration needs. Ensure the output clearly represents the sequence of binary data that was originally modulated.
6. Program Flow
- Structure your program to follow a clear flow:
  1. Input acquisition: Read or accept the array/list of QPSK symbols.
  2. Processing: Convert the QPSK symbols back into the binary sequence.
  3. Output: Display or write out the binary sequence.
7. Testing and Validation
- Develop test cases using known symbol-to-binary mappings to validate your demodulator. Ensure that your program accurately demodulates symbols to the correct binary sequences. Test with various inputs to cover all possible symbols in the QPSK constellation.

## Additional Considerations

### Error Handling

Add error handling for invalid inputs, such as symbols that do not correspond to any point in the QPSK constellation diagram (though this should not occur under ideal conditions).

### Integration with Modulator

Ensure your demodulator works seamlessly with the modulator you've developed. It's a good idea to test them together, using the output from your modulator as the input for your demodulator.

### Understanding Limitations

Recognize that this implementation assumes ideal conditions. In real-world scenarios, noise and other factors complicate demodulation, which can be explored in future projects. By completing this detailed task, you'll deepen your understanding of digital demodulation techniques and further develop your C++ programming skills, setting a solid foundation for exploring more complex communication system simulations.

## Run program

1. Build container image (optional)
    ```
    docker-compose build demodulator
    ```
2. Run program
  - Providing data via standard input, expecting result on standard output
    ```
    echo '(0.7,0.7)(+0.7,-0.7) (I-0.7,Q+0.7)(I-0.7,-0.7)' | docker-compose run -T demodulator
    ```
  - Providing data from a file, expecting result on standard output
    ```
    docker-compose run -T demodulator < input
    ```
  - Providing data via standard input, expecting result in specified file
    ```
    echo '(I0.7,Q0.7)(I0.7,Q-0.7)(I-0.7,Q0.7)(I-0.7,Q-0.7)' | docker-compose run -T demodulator > result
    ```
  - Providing data from a file, expecting result in specified file
    ```
    docker-compose run -T demodulator < input > result
    ```

## Integrate with modulator

1. Build container images (optional)
    ```
    docker-compose build modulator demodulator
    ```
2. Run containers
  - Providing data via standard input
    ```
    echo 01001011010010 | docker-compose run -T modulator | docker-compose run -T demodulator
    ```
  - Providing 1000 random bits via standard input
    ```
    docker-compose run random-bits 1000 | docker-compose run -T modulator | docker-compose run -T demodulator
    ```
  - Providing infinite sequence of random bits via standard input
    > :warning: You will have to kill running services using another terminal window
    > ```
    > docker-compose kill
    > ```
    ```
    docker-compose run random-bits | docker-compose run -T modulator | docker-compose run -T demodulator
    ```

## Run tests

1. Start terminal
    ```
    docker-compose run --build terminal
    ```

2. Configure projects using CMake
    ```
    cmake .
    ```

3. Build and run tests
    ```
    make qpsk-demodulator-test && bin/qpsk-demodulator-test
    ```
